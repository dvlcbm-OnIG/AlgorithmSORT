<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort Playground</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
:root {
    --bg: #0f172a;
    --panel: #111c34;
    --muted: #8ba0c2;
    --text: #e8efff;
    --accent: #f5a524;
    --accent-2: #2dd4bf;
}

* { box-sizing: border-box; }

body {
    margin: 0;
    min-height: 100vh;
    font-family: 'Manrope', sans-serif;
    background: radial-gradient(circle at 20% 20%, rgba(45, 212, 191, 0.12), transparent 30%),
                radial-gradient(circle at 80% 0%, rgba(245, 165, 36, 0.15), transparent 35%),
                linear-gradient(135deg, #0b1224, #0f172a 55%, #0b1224);
    color: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 48px 16px;
}

.wrap {
    width: min(1100px, 100%);
    display: grid;
    grid-template-columns: 1.1fr 0.9fr;
    grid-template-areas:
        "hero hero"
        "controls status"
        "array log";
    gap: 16px;
}

header {
    grid-area: hero;
    background: rgba(17, 28, 52, 0.75);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 16px;
    padding: 20px 24px 18px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.eyebrow {
    margin: 0;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--muted);
    font-size: 12px;
}

h1 {
    margin: 6px 0 8px;
    font-size: clamp(28px, 3vw, 40px);
}

.lede {
    margin: 0;
    max-width: 720px;
    color: #c2d4f3;
    line-height: 1.6;
}

.card {
    background: rgba(17, 28, 52, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 14px;
    padding: 16px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
}

.controls { grid-area: controls; }
.status { grid-area: status; display: grid; gap: 10px; align-content: start; }
.array { grid-area: array; }
.log { grid-area: log; }

.field { display: grid; gap: 6px; margin-bottom: 12px; }
label { color: var(--muted); font-size: 13px; }
input, select {
    width: 100%;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: #0b1224;
    color: var(--text);
    font-size: 15px;
}
select {
    cursor: pointer;
}
select:hover {
    border-color: rgba(255, 255, 255, 0.12);
}
select option {
    background: #0b1224;
    color: var(--text);
}
input[type="range"] {
    cursor: pointer;
    accent-color: var(--accent);
}
input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent), #fbbf24);
    cursor: pointer;
    border: 2px solid #0b1224;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.1);
    box-shadow: 0 0 12px var(--accent);
}
input[type="range"]::-webkit-slider-runnable-track {
    height: 6px;
    border-radius: 3px;
    background: #0b1224;
    border: 1px solid rgba(255, 255, 255, 0.06);
}
input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--accent), #fbbf24);
    cursor: pointer;
    border: 2px solid #0b1224;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
input[type="range"]::-moz-range-track {
    height: 6px;
    border-radius: 3px;
    background: #0b1224;
    border: 1px solid rgba(255, 255, 255, 0.06);
}

.buttons { display: flex; gap: 8px; flex-wrap: wrap; }
button {
    cursor: pointer;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 700;
    color: #0b1224;
    background: linear-gradient(135deg, var(--accent), #fbbf24);
    transition: transform 120ms ease, box-shadow 150ms ease, filter 150ms ease;
}
button:hover { transform: translateY(-1px); filter: brightness(1.05); }
button:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }
.ghost { background: #0b1224; color: var(--text); border: 1px solid rgba(255, 255, 255, 0.08); }

.hint { margin: 6px 0 0; color: var(--muted); font-size: 13px; }

.stat {
    display: flex;
    justify-content: space-between;
    padding: 10px 12px;
    background: #0b1224;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    font-weight: 600;
}
.stat span { color: var(--accent-2); }

.progress {
    position: relative;
    height: 10px;
    background: #0b1224;
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.06);
}
.progress .bar {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
}

.bars {
    display: flex;
    align-items: flex-end;
    gap: 1px;
    height: 240px;
    padding: 8px;
    background: #0b1224;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
    width: 100%;
    overflow: hidden;
}
.bar {
    position: relative;
    flex: 1 1 0;
    min-width: 1px;
    border-radius: 2px;
    border: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
    transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1), 
                height 300ms cubic-bezier(0.4, 0, 0.2, 1),
                box-shadow 300ms ease,
                filter 300ms ease;
    overflow: hidden;
    will-change: transform;
}
.bar:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
.bar:hover { transform: translateY(-3px); }
.bar.zero { background: #18243f; border-style: dashed; }
.bar.comparing {
    border-color: rgba(245, 165, 36, 0.8);
    box-shadow: 0 0 20px rgba(245, 165, 36, 0.4), 0 2px 8px rgba(0, 0, 0, 0.25);
    transform: translateY(-8px) scaleY(1.02);
}
.bar.swapping {
    box-shadow: 0 0 25px rgba(45, 212, 191, 0.5), 0 2px 8px rgba(0, 0, 0, 0.25);
    filter: brightness(1.2);
    z-index: 10;
}
.bar.sorted {
    box-shadow: 0 0 15px rgba(34, 197, 94, 0.3), 0 2px 8px rgba(0, 0, 0, 0.25);
}
.bar .value {
    position: absolute;
    bottom: 6px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: 700;
    font-size: 13px;
    color: #0b1224;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
    pointer-events: none;
    transition: all 300ms ease;
    opacity: 1;
}
.bars:has(> .bar:nth-child(100)) .bar .value {
    opacity: 0;
    font-size: 0;
}
.bars.empty { justify-content: center; align-items: center; color: var(--muted); font-weight: 600; }

.log-area {
    background: #0b1224;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    padding: 12px;
    max-height: 240px;
    overflow: auto;
    font-family: "SFMono-Regular", "JetBrains Mono", "Fira Code", monospace;
    font-size: 14px;
    color: #c6d5f7;
}

.badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(45, 212, 191, 0.1);
    border: 1px solid rgba(45, 212, 191, 0.35);
    color: var(--accent-2);
    font-weight: 700;
    margin-top: 6px;
}

@media (max-width: 900px) {
    .wrap {
        grid-template-columns: 1fr;
        grid-template-areas:
            "hero"
            "controls"
            "status"
            "array"
            "log";
    }
}
    </style>
</head>
<body>
    <div class="wrap">
        <header>
            <p class="eyebrow">sorting algorithms visualizer</p>
            <h1>Sorting Playground</h1>
            <p class="lede">Choose from 4 classic sorting algorithms and watch them come to life as animated histograms. Enter values, select an algorithm, and listen to each swap.</p>
        </header>

        <section class="controls card">
            <div class="field">
                <label for="sortType">Sorting Algorithm</label>
                <select id="sortType">
                    <option value="quick">Quick Sort</option>
                    <option value="bubble">Bubble Sort</option>
                    <option value="merge">Merge Sort</option>
                    <option value="selection">Selection Sort</option>
                    <option value="counting">Counting Sort (Fastest)</option>
                </select>
            </div>
            <div class="field">
                <label for="numbers">Numbers (comma or space separated)</label>
                <input id="numbers" type="text" value="3, 1, 4, 2" autocomplete="off">
            </div>
            <div class="field">
                <label for="randomCount">Number of columns: <span id="columnCount">10</span></label>
                <input id="randomCount" type="number" min="2" max="1000" value="10">
            </div>
            <div class="field">
                <label for="randomMin">Random range: Min</label>
                <input id="randomMin" type="number" value="1">
            </div>
            <div class="field">
                <label for="randomMax">Random range: Max</label>
                <input id="randomMax" type="number" value="100">
            </div>
            <button id="generateBtn" class="ghost" style="margin-bottom: 12px; width: 100%;">Generate Random Array</button>
            <div class="field">
                <label for="maxIterations">Max operations (failsafe)</label>
                <input id="maxIterations" type="number" min="1" value="8000">
            </div>
            <div class="field">
                <label for="speed">Animation speed: <span id="speedValue">1x</span></label>
                <input id="speed" type="range" min="0.1" max="200" step="0.1" value="1">
            </div>
            <div class="buttons">
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="ghost" disabled>Stop</button>
                <button id="resetBtn" class="ghost">Reset</button>
            </div>
            <p class=".hint">Runs an in-place quick sort. Max operations caps the animation so it never locks up.</p>
        </section>

        <section class="status card">
            <div class="stat">Operations <span id="iteration">0</span></div>
            <div class="stat">Elapsed (ms) <span id="elapsed">0</span></div>
            <div class="stat">Array length <span id="length">0</span></div>
            <div class="stat">State <span id="state">Idle</span></div>
            <div class="progress"><div class="bar" id="progressBar"></div></div>
            <div class="badge" id="badge">Waiting…</div>
        </section>

        <section class="array card">
            <h3 style="margin: 0 0 12px;">Current array</h3>
            <div class="bars" id="arrayView"></div>
        </section>

        <section class="log card">
            <h3 style="margin: 0 0 10px;">Event log</h3>
            <div class="log-area" id="log"></div>
        </section>
    </div>

    <script>
const sortTypeSelect = document.getElementById('sortType');
const numbersInput = document.getElementById('numbers');
const maxIterationsInput = document.getElementById('maxIterations');
const speedInput = document.getElementById('speed');
const speedValue = document.getElementById('speedValue');
const randomCountInput = document.getElementById('randomCount');
const columnCount = document.getElementById('columnCount');
const randomMinInput = document.getElementById('randomMin');
const randomMaxInput = document.getElementById('randomMax');
const generateBtn = document.getElementById('generateBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');

const iterationEl = document.getElementById('iteration');
const elapsedEl = document.getElementById('elapsed');
const lengthEl = document.getElementById('length');
const stateEl = document.getElementById('state');
const progressBar = document.getElementById('progressBar');
const badge = document.getElementById('badge');
const arrayView = document.getElementById('arrayView');
const logArea = document.getElementById('log');

let data = [];
let operations = 0;
let running = false;
let startTime = 0;
let audioCtx = null;
let barElements = [];
let speed = 1;

const parseNumbers = () => {
    const raw = numbersInput.value.trim();
    if (!raw) return [];
    return raw
        .split(/[ ,]+/)
        .map(Number)
        .filter((n) => Number.isFinite(n));
};

const generateRandomArray = () => {
    const count = Math.max(2, Math.min(1000, parseInt(randomCountInput.value) || 10));
    const min = parseInt(randomMinInput.value) || 1;
    const max = parseInt(randomMaxInput.value) || 100;
    const actualMin = Math.min(min, max);
    const actualMax = Math.max(min, max);
    const randomNumbers = [];
    for (let i = 0; i < count; i++) {
        const randomNum = Math.floor(Math.random() * (actualMax - actualMin + 1)) + actualMin;
        randomNumbers.push(randomNum);
    }
    numbersInput.value = randomNumbers.join(', ');
    log(`Generated ${count} columns with random numbers between ${actualMin} and ${actualMax}`);
    reset();
};

const computeRanks = (arr) => {
    if (!arr.length) return [];
    const sorted = arr
        .map((v, idx) => ({ v, idx }))
        .sort((a, b) => (a.v === b.v ? a.idx - b.idx : a.v - b.v));
    const buckets = new Map();
    sorted.forEach((item, i) => {
        if (!buckets.has(item.v)) buckets.set(item.v, []);
        buckets.get(item.v).push(i);
    });
    return arr.map((v) => buckets.get(v).shift());
};

const renderArray = (activeIndices = [], skipRecreate = false) => {
    if (!data.length) {
        arrayView.classList.add('empty');
        arrayView.textContent = 'No data to show';
        barElements = [];
        return;
    }

    arrayView.classList.remove('empty');
    const ranks = computeRanks(data);
    const maxRank = Math.max(1, data.length - 1);

    if (skipRecreate && barElements.length === data.length) {
        barElements.forEach((bar, idx) => {
            const rank = ranks[idx];
            const heightPct = data.length === 1 ? 100 : 20 + (80 * rank) / maxRank;
            const n = data[idx];
            const isPos = n >= 0;
            const gradientTop = isPos ? '#34d399' : '#fbbf24';
            const gradientBottom = isPos ? '#0ea5e9' : '#f97316';
            bar.style.height = `${heightPct}%`;
            bar.style.background = `linear-gradient(180deg, ${gradientTop}, ${gradientBottom})`;
            bar.style.order = idx;
            bar.style.position = 'relative';
            bar.querySelector('.value').textContent = n;
            bar.className = 'bar';
            if (n === 0) bar.classList.add('zero');
            if (activeIndices.includes(idx)) bar.classList.add('swapping');
        });
        return;
    }

    arrayView.innerHTML = '';
    barElements = data.map((n, idx) => {
        const rank = ranks[idx];
        const heightPct = data.length === 1 ? 100 : 20 + (80 * rank) / maxRank;
        const isPos = n >= 0;
        const gradientTop = isPos ? '#34d399' : '#fbbf24';
        const gradientBottom = isPos ? '#0ea5e9' : '#f97316';
        const bar = document.createElement('div');
        bar.className = 'bar';
        if (n === 0) bar.classList.add('zero');
        if (activeIndices.includes(idx)) bar.classList.add('swapping');
        bar.style.height = `${heightPct}%`;
        bar.style.background = `linear-gradient(180deg, ${gradientTop}, ${gradientBottom})`;
        bar.style.order = idx;
        const valueSpan = document.createElement('span');
        valueSpan.className = 'value';
        valueSpan.textContent = n;
        bar.appendChild(valueSpan);
        arrayView.appendChild(bar);
        return bar;
    });
};

const log = (message) => {
    const time = new Date().toLocaleTimeString();
    const entry = `[${time}] ${message}`;
    logArea.textContent = `${entry}\n${logArea.textContent}`.trim().slice(0, 4000);
};

const updateStats = (status = 'Sorting') => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const elapsed = running ? performance.now() - startTime : 0;
    iterationEl.textContent = operations;
    elapsedEl.textContent = elapsed.toFixed(1);
    lengthEl.textContent = data.length;
    stateEl.textContent = status;
    const denom = Math.max(1, (data.length || 1) ** 2);
    const pct = Math.min(100, (operations / denom) * 100);
    progressBar.style.width = `${pct}%`;
};

const setBadge = (text, positive = false) => {
    badge.textContent = text;
    badge.style.borderColor = positive ? 'rgba(45, 212, 191, 0.55)' : 'rgba(245, 165, 36, 0.55)';
    badge.style.color = positive ? 'var(--accent-2)' : 'var(--accent)';
    badge.style.backgroundColor = positive ? 'rgba(45, 212, 191, 0.1)' : 'rgba(245, 165, 36, 0.1)';
};

const playSwapSound = (value) => {
    const vol = 0.12;
    if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        audioCtx = Ctx ? new Ctx() : null;
    }
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const norm = Math.tanh(value || 0);
    osc.type = 'square';
    osc.frequency.value = 220 + Math.abs(norm) * 320;
    gain.gain.value = vol;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(vol, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    osc.start(now);
    osc.stop(now + 0.12);
};

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const animateSwap = async (idx1, idx2) => {
    if (!barElements[idx1] || !barElements[idx2]) return;
    barElements[idx1].classList.add('swapping');
    barElements[idx2].classList.add('swapping');
    const bar1Rect = barElements[idx1].getBoundingClientRect();
    const bar2Rect = barElements[idx2].getBoundingClientRect();
    const distance = bar2Rect.left - bar1Rect.left;
    barElements[idx1].style.transform = `translateX(${distance}px)`;
    barElements[idx2].style.transform = `translateX(${-distance}px)`;
    const animationDuration = 500 / speed;
    barElements[idx1].style.transition = `transform ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
    barElements[idx2].style.transition = `transform ${animationDuration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
    await sleep(animationDuration);
    [data[idx1], data[idx2]] = [data[idx2], data[idx1]];
    [barElements[idx1], barElements[idx2]] = [barElements[idx2], barElements[idx1]];
    barElements[idx1].style.transform = '';
    barElements[idx2].style.transform = '';
    barElements[idx1].style.transition = '';
    barElements[idx2].style.transition = '';
    renderArray([], true);
    barElements[idx1].classList.remove('swapping');
    barElements[idx2].classList.remove('swapping');
};

const stopRun = (reason = 'Stopped') => {
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setBadge(reason, reason === 'Sorted!');
    updateStats(reason);
};

const bubbleSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const n = data.length;

    for (let i = 0; i < n - 1 && running; i++) {
        for (let j = 0; j < n - i - 1 && running; j++) {
            if (data[j] > data[j + 1]) {
                operations += 1;
                updateStats('Sorting');
                playSwapSound(data[j]);
                await animateSwap(j, j + 1);
                if (operations >= maxOps) {
                    log('Stopped: max operations reached');
                    stopRun('Capped');
                    return;
                }
            }
        }
    }

    if (running) {
        renderArray();
        log('Sorted via bubble sort');
        stopRun('Sorted!');
    }
};

const selectionSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const n = data.length;

    for (let i = 0; i < n - 1 && running; i++) {
        let minIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (data[j] < data[minIdx]) {
                minIdx = j;
            }
        }
        if (minIdx !== i) {
            operations += 1;
            updateStats('Sorting');
            playSwapSound(data[i]);
            await animateSwap(i, minIdx);
            if (operations >= maxOps) {
                log('Stopped: max operations reached');
                stopRun('Capped');
                return;
            }
        }
    }

    if (running) {
        renderArray();
        log('Sorted via selection sort');
        stopRun('Sorted!');
    }
};

const countingSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    let minVal = data[0];
    let maxVal = data[0];
    for (let i = 1; i < data.length; i++) {
        if (data[i] < minVal) minVal = data[i];
        if (data[i] > maxVal) maxVal = data[i];
    }
    const range = maxVal - minVal + 1;
    const count = new Array(range).fill(0);
    for (let i = 0; i < data.length && running; i++) {
        count[data[i] - minVal]++;
        operations += 1;
        renderArray([i], true);
        updateStats('Sorting');
        if (operations >= maxOps) {
            log('Stopped: max operations reached');
            stopRun('Capped');
            return;
        }
        await sleep(20 / speed);
    }
    for (let i = 1; i < count.length && running; i++) {
        count[i] += count[i - 1];
        await sleep(5 / speed);
    }
    const output = new Array(data.length);
    for (let i = data.length - 1; i >= 0 && running; i--) {
        const value = data[i];
        const idx = count[value - minVal] - 1;
        output[idx] = value;
        count[value - minVal]--;
        operations += 1;
        renderArray([idx], true);
        updateStats('Sorting');
        playSwapSound(value);
        if (operations >= maxOps) {
            log('Stopped: max operations reached');
            stopRun('Capped');
            return;
        }
        await sleep(30 / speed);
    }
    for (let i = 0; i < output.length; i++) {
        data[i] = output[i];
    }
    if (running) {
        renderArray();
        log('Sorted via counting sort');
        stopRun('Sorted!');
    }
};

const mergeSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;

    const merge = async (left, mid, right) => {
        const leftArr = data.slice(left, mid + 1);
        const rightArr = data.slice(mid + 1, right + 1);
        let i = 0, j = 0, k = left;

        while (i < leftArr.length && j < rightArr.length && running) {
            if (leftArr[i] <= rightArr[j]) {
                data[k] = leftArr[i];
                i++;
            } else {
                data[k] = rightArr[j];
                j++;
            }
            operations += 1;
            renderArray([k], true);
            updateStats('Sorting');
            playSwapSound(data[k]);
            if (operations >= maxOps) {
                log('Stopped: max operations reached');
                stopRun('Capped');
                return false;
            }
            k++;
            await sleep(80 / speed);
        }

        while (i < leftArr.length && running) {
            data[k] = leftArr[i];
            renderArray([k], true);
            i++;
            k++;
            await sleep(60 / speed);
        }

        while (j < rightArr.length && running) {
            data[k] = rightArr[j];
            renderArray([k], true);
            j++;
            k++;
            await sleep(60 / speed);
        }
        return true;
    };

    const mergeSortHelper = async (left, right) => {
        if (left >= right || !running) return true;
        const mid = Math.floor((left + right) / 2);
        if (!await mergeSortHelper(left, mid)) return false;
        if (!await mergeSortHelper(mid + 1, right)) return false;
        return await merge(left, mid, right);
    };

    await mergeSortHelper(0, data.length - 1);

    if (running) {
        renderArray();
        log('Sorted via merge sort');
        stopRun('Sorted!');
    }
};

const quickSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const stack = [[0, data.length - 1]];

    while (stack.length && running) {
        const [low, high] = stack.pop();
        if (low >= high) continue;

        let i = low;
        let j = high;
        const pivotIdx = Math.floor((low + high) / 2);
        const pivot = data[pivotIdx];

        while (i <= j && running) {
            while (data[i] < pivot) i += 1;
            while (data[j] > pivot) j -= 1;
            if (i <= j) {
                if (i !== j) {
                    operations += 1;
                    updateStats('Sorting');
                    playSwapSound(data[i]);
                    await animateSwap(i, j);
                    if (operations >= maxOps) {
                        log('Stopped: max operations reached');
                        stopRun('Capped');
                        return;
                    }
                }
                i += 1;
                j -= 1;
            }
        }

        if (low < j) stack.push([low, j]);
        if (i < high) stack.push([i, high]);
    }

    if (running) {
        renderArray();
        log('Sorted via quick sort');
        stopRun('Sorted!');
    }
};

const start = async () => {
    data = parseNumbers();
    if (!data.length) {
        log('Enter at least one number.');
        setBadge('Need data');
        return;
    }

    operations = 0;
    running = true;
    startTime = performance.now();
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setBadge('Sorting…');
    renderArray();
    updateStats('Sorting');
    const sortType = sortTypeSelect.value;
    const sortNames = {
        quick: 'quick sort',
        bubble: 'bubble sort',
        merge: 'merge sort',
        selection: 'selection sort',
        counting: 'counting sort'
    };
    log(`Starting ${sortNames[sortType]} with [${data.join(', ')}] (n=${data.length})`);
    switch (sortType) {
        case 'bubble':
            await bubbleSortAnimate();
            break;
        case 'merge':
            await mergeSortAnimate();
            break;
        case 'selection':
            await selectionSortAnimate();
            break;
        case 'counting':
            await countingSortAnimate();
            break;
        case 'quick':
        default:
            await quickSortAnimate();
            break;
    }
};

const reset = () => {
    data = parseNumbers();
    operations = 0;
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setBadge('Waiting…');
    renderArray();
    updateStats('Idle');
    log('Reset state');
};

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', () => {
    log('Stopped by user');
    stopRun('Paused');
});
resetBtn.addEventListener('click', reset);
generateBtn.addEventListener('click', generateRandomArray);

randomCountInput.addEventListener('input', () => {
    const count = Math.max(2, Math.min(1000, parseInt(randomCountInput.value) || 10));
    randomCountInput.value = count;
    columnCount.textContent = count;
});

speedInput.addEventListener('input', () => {
    speed = parseFloat(speedInput.value);
    speedValue.textContent = `${speed}x`;
});

sortTypeSelect.addEventListener('change', reset);
numbersInput.addEventListener('change', reset);
maxIterationsInput.addEventListener('change', reset);

reset();
    </script>
</body>
</html>
