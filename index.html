<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort Playground</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
:root {
    --bg: #0f172a;
    --panel: #111c34;
    --muted: #8ba0c2;
    --text: #e8efff;
    --accent: #f5a524;
    --accent-2: #2dd4bf;
}

* { box-sizing: border-box; }

body {
    margin: 0;
    min-height: 100vh;
    font-family: 'Manrope', sans-serif;
    background: radial-gradient(circle at 20% 20%, rgba(45, 212, 191, 0.12), transparent 30%),
                radial-gradient(circle at 80% 0%, rgba(245, 165, 36, 0.15), transparent 35%),
                linear-gradient(135deg, #0b1224, #0f172a 55%, #0b1224);
    color: var(--text);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 48px 16px;
}

.wrap {
    width: min(1100px, 100%);
    display: grid;
    grid-template-columns: 1.1fr 0.9fr;
    grid-template-areas:
        "hero hero"
        "controls status"
        "array log";
    gap: 16px;
}

header {
    grid-area: hero;
    background: rgba(17, 28, 52, 0.75);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.06);
    border-radius: 16px;
    padding: 20px 24px 18px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.eyebrow {
    margin: 0;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: var(--muted);
    font-size: 12px;
}

h1 {
    margin: 6px 0 8px;
    font-size: clamp(28px, 3vw, 40px);
}

.lede {
    margin: 0;
    max-width: 720px;
    color: #c2d4f3;
    line-height: 1.6;
}

.card {
    background: rgba(17, 28, 52, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 14px;
    padding: 16px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
}

.controls { grid-area: controls; }
.status { grid-area: status; display: grid; gap: 10px; align-content: start; }
.array { grid-area: array; }
.log { grid-area: log; }

.field { display: grid; gap: 6px; margin-bottom: 12px; }
label { color: var(--muted); font-size: 13px; }
input {
    width: 100%;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: #0b1224;
    color: var(--text);
    font-size: 15px;
}

.buttons { display: flex; gap: 8px; flex-wrap: wrap; }
button {
    cursor: pointer;
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 700;
    color: #0b1224;
    background: linear-gradient(135deg, var(--accent), #fbbf24);
    transition: transform 120ms ease, box-shadow 150ms ease, filter 150ms ease;
}
button:hover { transform: translateY(-1px); filter: brightness(1.05); }
button:disabled { opacity: 0.45; cursor: not-allowed; transform: none; }
.ghost { background: #0b1224; color: var(--text); border: 1px solid rgba(255, 255, 255, 0.08); }

.hint { margin: 6px 0 0; color: var(--muted); font-size: 13px; }

.stat {
    display: flex;
    justify-content: space-between;
    padding: 10px 12px;
    background: #0b1224;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    font-weight: 600;
}
.stat span { color: var(--accent-2); }

.progress {
    position: relative;
    height: 10px;
    background: #0b1224;
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.06);
}
.progress .bar {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
}

.bars {
    display: flex;
    align-items: flex-end;
    gap: 8px;
    height: 240px;
    padding: 12px;
    background: #0b1224;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
}
.bar {
    position: relative;
    flex: 1;
    min-width: 26px;
    border-radius: 10px 10px 6px 6px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.06);
    transition: height 140ms ease, transform 120ms ease;
    overflow: hidden;
}
.bar:hover { transform: translateY(-3px); }
.bar.zero { background: #18243f; border-style: dashed; }
.bar .value {
    position: absolute;
    bottom: 6px;
    left: 50%;
    transform: translateX(-50%);
    font-weight: 700;
    font-size: 13px;
    color: #0b1224;
    text-shadow: 0 1px 0 rgba(255, 255, 255, 0.4);
    pointer-events: none;
}
.bars.empty { justify-content: center; align-items: center; color: var(--muted); font-weight: 600; }

.log-area {
    background: #0b1224;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    padding: 12px;
    max-height: 240px;
    overflow: auto;
    font-family: "SFMono-Regular", "JetBrains Mono", "Fira Code", monospace;
    font-size: 14px;
    color: #c6d5f7;
}

.badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(45, 212, 191, 0.1);
    border: 1px solid rgba(45, 212, 191, 0.35);
    color: var(--accent-2);
    font-weight: 700;
    margin-top: 6px;
}

@media (max-width: 900px) {
    .wrap {
        grid-template-columns: 1fr;
        grid-template-areas:
            "hero"
            "controls"
            "status"
            "array"
            "log";
    }
}
    </style>
</head>
<body>
    <div class="wrap">
        <header>
            <p class="eyebrow">divide-and-conquer demo</p>
            <h1>Quick Sort Playground</h1>
            <p class="lede">Quick sort partitions and conquers—now rendered as a live histogram. Enter values, hit Start, and listen to each swap.</p>
        </header>

        <section class="controls card">
            <div class="field">
                <label for="numbers">Numbers (comma or space separated)</label>
                <input id="numbers" type="text" value="3, 1, 4, 2" autocomplete="off">
            </div>
            <div class="field">
                <label for="maxIterations">Max operations (failsafe)</label>
                <input id="maxIterations" type="number" min="1" value="8000">
            </div>
            <div class="buttons">
                <button id="startBtn">Start</button>
                <button id="stopBtn" class="ghost" disabled>Stop</button>
                <button id="resetBtn" class="ghost">Reset</button>
            </div>
            <p class="hint">Runs an in-place quick sort. Max operations caps the animation so it never locks up.</p>
        </section>

        <section class="status card">
            <div class="stat">Operations <span id="iteration">0</span></div>
            <div class="stat">Elapsed (ms) <span id="elapsed">0</span></div>
            <div class="stat">Array length <span id="length">0</span></div>
            <div class="stat">State <span id="state">Idle</span></div>
            <div class="progress"><div class="bar" id="progressBar"></div></div>
            <div class="badge" id="badge">Waiting…</div>
        </section>

        <section class="array card">
            <h3 style="margin: 0 0 12px;">Current array</h3>
            <div class="bars" id="arrayView"></div>
        </section>

        <section class="log card">
            <h3 style="margin: 0 0 10px;">Event log</h3>
            <div class="log-area" id="log"></div>
        </section>
    </div>

    <script>
const numbersInput = document.getElementById('numbers');
const maxIterationsInput = document.getElementById('maxIterations');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const resetBtn = document.getElementById('resetBtn');

const iterationEl = document.getElementById('iteration');
const elapsedEl = document.getElementById('elapsed');
const lengthEl = document.getElementById('length');
const stateEl = document.getElementById('state');
const progressBar = document.getElementById('progressBar');
const badge = document.getElementById('badge');
const arrayView = document.getElementById('arrayView');
const logArea = document.getElementById('log');

let data = [];
let operations = 0;
let running = false;
let startTime = 0;
let audioCtx = null;

const parseNumbers = () => {
    const raw = numbersInput.value.trim();
    if (!raw) return [];
    return raw
        .split(/[ ,]+/)
        .map(Number)
        .filter((n) => Number.isFinite(n));
};

const computeRanks = (arr) => {
    if (!arr.length) return [];
    const sorted = arr
        .map((v, idx) => ({ v, idx }))
        .sort((a, b) => (a.v === b.v ? a.idx - b.idx : a.v - b.v));
    const buckets = new Map();
    sorted.forEach((item, i) => {
        if (!buckets.has(item.v)) buckets.set(item.v, []);
        buckets.get(item.v).push(i);
    });
    return arr.map((v) => buckets.get(v).shift());
};

const renderArray = () => {
    if (!data.length) {
        arrayView.classList.add('empty');
        arrayView.textContent = 'No data to show';
        return;
    }

    arrayView.classList.remove('empty');
    const ranks = computeRanks(data);
    const maxRank = Math.max(1, data.length - 1);

    arrayView.innerHTML = data
        .map((n, idx) => {
            const rank = ranks[idx];
            const heightPct = data.length === 1 ? 100 : 20 + (80 * rank) / maxRank;
            const isPos = n >= 0;
            const gradientTop = isPos ? '#34d399' : '#fbbf24';
            const gradientBottom = isPos ? '#0ea5e9' : '#f97316';
            const extraClass = n === 0 ? ' zero' : '';
            return `
                <div class="bar${extraClass}" style="height:${heightPct}%; background: linear-gradient(180deg, ${gradientTop}, ${gradientBottom});">
                    <span class="value">${n}</span>
                </div>
            `;
        })
        .join('');
};

const log = (message) => {
    const time = new Date().toLocaleTimeString();
    const entry = `[${time}] ${message}`;
    logArea.textContent = `${entry}\n${logArea.textContent}`.trim().slice(0, 4000);
};

const updateStats = (status = 'Sorting') => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const elapsed = running ? performance.now() - startTime : 0;
    iterationEl.textContent = operations;
    elapsedEl.textContent = elapsed.toFixed(1);
    lengthEl.textContent = data.length;
    stateEl.textContent = status;
    const denom = Math.max(1, (data.length || 1) ** 2);
    const pct = Math.min(100, (operations / denom) * 100);
    progressBar.style.width = `${pct}%`;
};

const setBadge = (text, positive = false) => {
    badge.textContent = text;
    badge.style.borderColor = positive ? 'rgba(45, 212, 191, 0.55)' : 'rgba(245, 165, 36, 0.55)';
    badge.style.color = positive ? 'var(--accent-2)' : 'var(--accent)';
    badge.style.backgroundColor = positive ? 'rgba(45, 212, 191, 0.1)' : 'rgba(245, 165, 36, 0.1)';
};

const playSwapSound = (value) => {
    const vol = 0.12;
    if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        audioCtx = Ctx ? new Ctx() : null;
    }
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const norm = Math.tanh(value || 0);
    osc.type = 'square';
    osc.frequency.value = 220 + Math.abs(norm) * 320;
    gain.gain.value = vol;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(vol, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    osc.start(now);
    osc.stop(now + 0.12);
};

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const stopRun = (reason = 'Stopped') => {
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setBadge(reason, reason === 'Sorted!');
    updateStats(reason);
};

const quickSortAnimate = async () => {
    const maxOps = Number(maxIterationsInput.value) || 1;
    const stack = [[0, data.length - 1]];

    while (stack.length && running) {
        const [low, high] = stack.pop();
        if (low >= high) continue;

        let i = low;
        let j = high;
        const pivot = data[Math.floor((low + high) / 2)];

        while (i <= j && running) {
            while (data[i] < pivot) i += 1;
            while (data[j] > pivot) j -= 1;
            if (i <= j) {
                [data[i], data[j]] = [data[j], data[i]];
                operations += 1;
                renderArray();
                updateStats('Sorting');
                playSwapSound(data[i]);
                if (operations >= maxOps) {
                    log('Stopped: max operations reached');
                    stopRun('Capped');
                    return;
                }
                i += 1;
                j -= 1;
                await sleep(30);
            }
        }

        if (low < j) stack.push([low, j]);
        if (i < high) stack.push([i, high]);
    }

    if (running) {
        log('Sorted via quick sort');
        stopRun('Sorted!');
    }
};

const start = async () => {
    data = parseNumbers();
    if (!data.length) {
        log('Enter at least one number.');
        setBadge('Need data');
        return;
    }

    operations = 0;
    running = true;
    startTime = performance.now();
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setBadge('Sorting…');
    renderArray();
    updateStats('Sorting');
    log(`Starting quick sort with [${data.join(', ')}] (n=${data.length})`);
    await quickSortAnimate();
};

const reset = () => {
    data = parseNumbers();
    operations = 0;
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setBadge('Waiting…');
    renderArray();
    updateStats('Idle');
    log('Reset state');
};

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', () => {
    log('Stopped by user');
    stopRun('Paused');
});
resetBtn.addEventListener('click', reset);

numbersInput.addEventListener('change', reset);
maxIterationsInput.addEventListener('change', reset);

// initial render
reset();
    </script>
</body>
</html>